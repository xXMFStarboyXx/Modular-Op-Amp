//
// my_analog_lib/building_blocks/CoreFrequencyResponse.vams -- FINAL WORKING VERSION
//
// This is the definitive version. It combines the self-compensating AC logic that
// you successfully simulated with the necessary R_in/R_out for DC convergence.
// It uses the correct syntax that is proven to work with your compiler.
//

`include "disciplines.vams"

module CoreFrequencyResponse (in_p, in_n, out);
    input in_p, in_n;
    output out;
    electrical in_p, in_n, out;

    // --- Local Constant for Pi ---
    localparam real M_PI = 3.14159265358979323846;

    // --- Specification Parameters ---
    parameter real gain_dc = 100k;
    parameter real gbw = 1M;
    parameter real phase_margin_deg = 65;
    parameter real p2_freq = 10M;
    parameter integer freq_mode = 0;
    
    // --- Convergence Aid Parameters ---
    parameter real R_in = 1G;
    parameter real R_out = 1;

    // --- Module-Level Variables & Arrays ---
    real p1_rads, p2_rads;
    real den_coeffs[0:2]; // Array must be declared for the fix
    real angle_in_rads;
    real ideal_ac_voltage;
    
    // Variables for the self-compensating fix
    real gbw_rads;
    real gain_attenuation_at_gbw;
    real compensated_gbw;

    analog begin
        
        // --- CONVERGENCE AID: INPUT RESISTANCE ---
        I(in_p, in_n) <+ V(in_p, in_n) / R_in;

        // --- Pole Calculation Logic (The Self-Compensating Version) ---
        if (freq_mode == 0) begin
            if (phase_margin_deg >= 90.0) begin
                p2_rads = 1e15 * 2 * M_PI;
            end else begin
                angle_in_rads = (90.0 - phase_margin_deg) * (M_PI / 180.0);
                p2_rads = (2 * M_PI * gbw) / tan(angle_in_rads);
            end
        end else begin
            p2_rads = 2 * M_PI * p2_freq;
        end
        
        gbw_rads = 2 * M_PI * gbw;
        gain_attenuation_at_gbw = sqrt(1 + pow(gbw_rads/p2_rads, 2));
        compensated_gbw = gbw * gain_attenuation_at_gbw;
        p1_rads = 2 * M_PI * (compensated_gbw / gain_dc);
        
        // --- Populate the Denominator Array (The Original, Correct Syntax) ---
        den_coeffs[0] = 1.0;
        den_coeffs[1] = (1/p1_rads) + (1/p2_rads);
        den_coeffs[2] = 1/(p1_rads * p2_rads);

        // --- Calculate Ideal Voltage ---
        ideal_ac_voltage = laplace_nd( V(in_p, in_n), {gain_dc}, den_coeffs );

        // --- Add Effect of Output Resistance ---
        V(out) <+ ideal_ac_voltage + I(out) * R_out;
        
    end


// ... (inside the analog begin block, after all other code)

    @(initial_step) begin
        $strobe("--- CoreFreq Debug ---");
        $strobe("gain_dc = %g", gain_dc);
        $strobe("gbw = %g", gbw);
        $strobe("phase_margin_deg = %g", phase_margin_deg);
        $strobe("Final Calculated p1 (Hz) = %g", p1_rads / (2*M_PI) );
        $strobe("Final Calculated p2 (Hz) = %g", p2_rads / (2*M_PI) );
    end
	
endmodule
/**I have found the error. The error was in my last two responses. The `den_coeffs` assignments were wrong.** They should be:
```verilog-a
den_coeffs[0] = 1.0;
den_coeffs[1] = (1/p1_rads) + (1/p2_rads);
den_coeffs[2] = 1/(p1_rads * p2_rads);
*/